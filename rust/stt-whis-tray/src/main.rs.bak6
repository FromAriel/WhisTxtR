use arboard::Clipboard;
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use cpal::{SampleFormat, Stream, StreamConfig};
use device_query::{DeviceQuery, DeviceState, Keycode};
use enigo::{Enigo, KeyboardControllable, Key};
use log::{error, info, warn};
use parking_lot::Mutex;
use serde::{Deserialize, Serialize};
use std::env;
use std::fs;
use std::num::NonZeroUsize;
use std::path::{Path, PathBuf};
use std::sync::mpsc::{self, Receiver, Sender};
use std::sync::Arc;
use std::thread;
use std::time::{Duration, Instant};
use thiserror::Error;
use whisper_rs::{
    FullParams, SamplingStrategy, WhisperContext, WhisperContextParameters,
};
use windows_sys::Win32::Foundation::{HWND, LPARAM, LRESULT, POINT, RECT, WPARAM};
use windows_sys::Win32::Graphics::Gdi::{
    CreateSolidBrush, DeleteObject, Ellipse, FillRect, GetDC, ReleaseDC, SelectObject, SetBkMode,
    SetTextColor, TextOutW, HBRUSH, TRANSPARENT,
};
use windows_sys::Win32::System::LibraryLoader::GetModuleHandleW;
use windows_sys::Win32::UI::Shell::{
    Shell_NotifyIconW, NIF_ICON, NIF_MESSAGE, NIF_TIP, NIM_ADD, NIM_DELETE, NOTIFYICONDATAW,
};
use windows_sys::Win32::UI::WindowsAndMessaging::{
    CreatePopupMenu, CreateWindowExW, DefWindowProcW, DispatchMessageW, GetCursorPos, LoadIconW,
    LoadImageW, MoveWindow, PeekMessageW, PostMessageW, PostQuitMessage, RegisterClassW, RemoveMenu,
    SetForegroundWindow, SetWindowPos, ShowWindow, TrackPopupMenu, TranslateMessage, CW_USEDEFAULT,
    HMENU, HWND_TOPMOST, IDI_APPLICATION, IMAGE_ICON, LR_SHARED, MF_BYPOSITION, MSG, PM_REMOVE,
    SW_HIDE, SW_SHOWNOACTIVATE, SWP_NOMOVE, SWP_NOSIZE, SWP_SHOWWINDOW, TPM_BOTTOMALIGN,
    TPM_LEFTALIGN, TPM_RETURNCMD, TPM_RIGHTBUTTON, WNDCLASSW, WM_COMMAND, WM_DESTROY, WM_NULL,
    WM_PAINT, WM_QUIT, WM_RBUTTONUP, WS_EX_TOOLWINDOW, WS_EX_TOPMOST, WS_OVERLAPPEDWINDOW, WS_POPUP,
};

const DEFAULT_MODEL_PATH: &str = "J:/whistxt/models/ggml-small-q5_1.bin";
const DEFAULT_HOTKEY: &str = "Ctrl+Shift";
const DEFAULT_POLL_HZ: u64 = 30;
const CUDA_BUILD_ENABLED: bool = cfg!(feature = "cuda");
const MAX_SAMPLES: usize = 16_000 * 120; // ~2 minutes of audio
const STARTUP_LINK_NAME: &str = "WhisTxtR.lnk";
const WM_TRAYICON: u32 = 0x0400 + 1;
const ID_TRAY_QUIT: u16 = 1;
const ID_TRAY_STARTUP: u16 = 2;
const OVERLAY_WIDTH: i32 = 520;
const OVERLAY_HEIGHT: i32 = 120;
const OVERLAY_HIDE_DELAY_MS: u128 = 2500;

#[derive(Debug, Error)]
enum AppError {
    #[error("IO: {0}")]
    Io(#[from] std::io::Error),
    #[error("JSON: {0}")]
    Json(#[from] serde_json::Error),
    #[error("{0}")]
    Msg(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
enum InjectMode {
    Clipboard,
    Keystroke,
}

impl Default for InjectMode {
    fn default() -> Self {
        InjectMode::Clipboard
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct HotkeyConfig {
    /// Simple hold-to-talk combo. Currently only Ctrl+Shift is supported.
    combo: String,
}

impl Default for HotkeyConfig {
    fn default() -> Self {
        Self {
            combo: DEFAULT_HOTKEY.to_string(),
        }
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
struct Config {
    #[serde(default = "default_model_path")]
    model_path: String,
    #[serde(default)]
    language: Option<String>,
    #[serde(default)]
    hotkey: HotkeyConfig,
    #[serde(default)]
    inject_mode: InjectMode,
    #[serde(default)]
    append_newline: bool,
    #[serde(default = "default_poll_hz")]
    poll_hz: u64,
    #[serde(default = "default_use_cuda")]
    use_cuda: bool,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            model_path: DEFAULT_MODEL_PATH.to_string(),
            language: None,
            hotkey: HotkeyConfig::default(),
            inject_mode: InjectMode::Clipboard,
            append_newline: false,
            poll_hz: DEFAULT_POLL_HZ,
            use_cuda: true,
        }
    }
}

fn default_model_path() -> String {
    DEFAULT_MODEL_PATH.to_string()
}

fn default_poll_hz() -> u64 {
    DEFAULT_POLL_HZ
}

fn default_use_cuda() -> bool {
    true
}

#[derive(Debug)]
enum SpeechEvent {
    RecordingStarted,
    RecordingStopped,
    Processing,
    Info(String),
    Transcript(String),
    Error(String),
}

#[derive(Debug)]
enum SpeechCommand {
    Start {
        model_path: String,
        language: Option<String>,
    },
    Stop,
    Cancel,
}

fn main() -> Result<(), AppError> {
    init_logging();
    let config_path = default_config_path();
    let config = load_or_init_config(&config_path)?;
    info!(
        "Loaded config from {} (use_cuda: {}, cuda build: {})",
        config_path.display(),
        config.use_cuda,
        CUDA_BUILD_ENABLED
    );
    if config.use_cuda && !CUDA_BUILD_ENABLED {
        warn!("Config requests CUDA but binary not built with --features cuda; recompile with --features cuda for GPU.");
    }

    let (speech_tx, speech_rx) = spawn_speech_runtime().map_err(AppError::Msg)?;

    let overlay_handle = start_overlay();

    start_keyboard_loop(config.clone(), speech_tx.clone());

    // Main loop: handle speech events and inject transcripts.
    app_loop(speech_rx, config, overlay_handle)?;
    Ok(())
}

fn init_logging() {
    let mut builder = env_logger::Builder::from_default_env();
    builder
        .format_timestamp_millis()
        .filter_level(log::LevelFilter::Info)
        .init();
}

fn default_config_path() -> PathBuf {
    if let Ok(appdata) = env::var("APPDATA") {
        PathBuf::from(appdata).join("WhisTray").join("config.json")
    } else {
        PathBuf::from("config.json")
    }
}

fn startup_link_path() -> PathBuf {
    let startup = env::var("APPDATA").unwrap_or_default();
    PathBuf::from(startup)
        .join("Microsoft")
        .join("Windows")
        .join("Start Menu")
        .join("Programs")
        .join("Startup")
        .join(STARTUP_LINK_NAME)
}

fn enable_startup() -> Result<(), String> {
    let exe = env::current_exe().map_err(|e| format!("exe path: {e}"))?;
    let link_path = startup_link_path();
    let sl = mslnk::ShellLink::new(exe).map_err(|e| format!("ShellLink: {e}"))?;
    sl.create_lnk(&link_path)
        .map_err(|e| format!("create startup link: {e}"))
}

fn disable_startup() -> Result<(), String> {
    let link_path = startup_link_path();
    if link_path.exists() {
        fs::remove_file(&link_path).map_err(|e| format!("remove link: {e}"))?;
    }
    Ok(())
}

fn is_startup_enabled() -> bool {
    startup_link_path().exists()
}

fn load_or_init_config(path: &Path) -> Result<Config, AppError> {
    if path.exists() {
        let data = fs::read_to_string(path)?;
        let mut cfg: Config = serde_json::from_str(&data)?;
        // If the stored model path is missing, reset to default local model copy.
        if !Path::new(&cfg.model_path).exists() {
            cfg.model_path = default_model_path();
            let updated = serde_json::to_string_pretty(&cfg)?;
            fs::write(path, updated)?;
        }
        return Ok(cfg);
    }
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }
    let cfg = Config::default();
    let data = serde_json::to_string_pretty(&cfg)?;
    fs::write(path, data)?;
    Ok(cfg)
}

fn start_keyboard_loop(config: Config, speech_tx: Sender<SpeechCommand>) {
    thread::spawn(move || {
        let device_state = DeviceState::new();
        let mut hotkey_down = false;
        let poll = Duration::from_millis(1000 / config.poll_hz.max(1));
        loop {
            let keys = device_state.get_keys();
            let ctrl = keys.contains(&Keycode::LControl)
                || keys.contains(&Keycode::RControl);
            let shift =
                keys.contains(&Keycode::LShift) || keys.contains(&Keycode::RShift);
            let down = ctrl && shift; // current combo support
            if down && !hotkey_down {
                hotkey_down = true;
                let _ = speech_tx.send(SpeechCommand::Start {
                    model_path: config.model_path.clone(),
                    language: config.language.clone(),
                });
                info!("Hotkey pressed: start recording");
            } else if !down && hotkey_down {
                hotkey_down = false;
                let _ = speech_tx.send(SpeechCommand::Stop);
                info!("Hotkey released: stop recording");
            }
            thread::sleep(poll);
        }
    });
}

fn app_loop(
    event_rx: Receiver<SpeechEvent>,
    config: Config,
    overlay: OverlayHandle,
) -> Result<(), AppError> {
    // Start Win32 tray (hidden window + notify icon)
    let mut tray = Tray::start(is_startup_enabled())?;

    // Block on Ctrl+C; process speech events and inject.
    ctrlc::set_handler(move || {
        info!("Ctrl+C received, exiting.");
        std::process::exit(0);
    })
    .map_err(|e| AppError::Msg(format!("failed to set Ctrl+C handler: {e}")))?;

    loop {
        // Pump window messages (tray); break if WM_QUIT received.
        if !tray.pump() {
            info!("Tray requested quit (WM_QUIT)");
            break;
        }

        let ev = match event_rx.recv_timeout(Duration::from_millis(50)) {
            Ok(ev) => ev,
            Err(std::sync::mpsc::RecvTimeoutError::Timeout) => continue,
            Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => break,
        };
        match ev {
            SpeechEvent::RecordingStarted => {
                info!("(speech) recording started");
                overlay.send(OverlayMsg::RecordingStart);
            }
            SpeechEvent::RecordingStopped => {
                info!("(speech) recording stopped");
                overlay.send(OverlayMsg::Hide);
            }
            SpeechEvent::Processing => {
                info!("(speech) processing");
                overlay.send(OverlayMsg::Processing);
            }
            SpeechEvent::Info(msg) => info!("(speech) {}", msg),
            SpeechEvent::Error(msg) => error!("(speech) {}", msg),
            SpeechEvent::Transcript(text) => {
                info!("(speech) transcript len={}", text.len());
                let to_inject = if config.append_newline {
                    format!("{text}\n")
                } else {
                    text
                };
                overlay.send(OverlayMsg::Transcript(to_inject.clone()));
                if let Err(e) = inject_text(&to_inject, config.inject_mode.clone()) {
                    error!("inject failed: {}", e);
                }
            }
        }

        // Handle tray commands (quit/startup toggle)
        while let Some(cmd) = tray.try_recv_cmd() {
            match cmd {
                TrayCmd::Quit => {
                    info!("Tray quit requested");
                    return Ok(());
                }
                TrayCmd::ToggleStartup => {
                    let now = !is_startup_enabled();
                    if now {
                        if let Err(e) = enable_startup() {
                            error!("Enable startup failed: {e}");
                        }
                    } else if let Err(e) = disable_startup() {
                        error!("Disable startup failed: {e}");
                    }
                    tray.set_startup_checked(is_startup_enabled());
                }
            }
        }
    }
    Ok(())
}

fn inject_text(text: &str, mode: InjectMode) -> Result<(), String> {
    if text.trim().is_empty() {
        return Ok(());
    }
    // Small delay to allow focus to return after hotkey release.
    thread::sleep(Duration::from_millis(30));
    match mode {
        InjectMode::Clipboard => inject_via_clipboard(text),
        InjectMode::Keystroke => inject_via_keystrokes(text),
    }
}

fn inject_via_clipboard(text: &str) -> Result<(), String> {
    let mut clipboard = Clipboard::new().map_err(|e| format!("clipboard: {e}"))?;
    let prior = clipboard.get_text().ok();
    clipboard
        .set_text(text.to_string())
        .map_err(|e| format!("set clipboard: {e}"))?;
    // Paste via Ctrl+V
    let mut enigo = Enigo::new();
    enigo.key_down(Key::Control);
    enigo.key_click(Key::Layout('v'));
    enigo.key_up(Key::Control);
    // Best-effort restore
    if let Some(old) = prior {
        let _ = clipboard.set_text(old);
    }
    Ok(())
}

fn inject_via_keystrokes(text: &str) -> Result<(), String> {
    let mut enigo = Enigo::new();
    enigo.key_sequence(text);
    Ok(())
}

fn spawn_speech_runtime(
) -> Result<(Sender<SpeechCommand>, Receiver<SpeechEvent>), String> {
    let (cmd_tx, cmd_rx) = mpsc::channel::<SpeechCommand>();
    let (evt_tx, evt_rx) = mpsc::channel::<SpeechEvent>();
    thread::spawn(move || {
        let mut stream: Option<Stream> = None;
        let mut last_sr: u32 = 16_000;
        let mut last_channels: u16 = 1;
        let mut ctx: Option<WhisperContext> = None;
        let mut ctx_model: Option<String> = None;
        let mut lang_opt: Option<String> = None;
        let audio_buf = Arc::new(Mutex::new(Vec::<f32>::new()));
        let host = cpal::default_host();

        let load_ctx = |path: &str,
                        cached_path: &mut Option<String>,
                        cached_ctx: &mut Option<WhisperContext>| {
            if cached_path.as_deref() == Some(path) && cached_ctx.is_some() {
                return Ok(());
            }
            let params = WhisperContextParameters::default();
            match WhisperContext::new_with_params(path, params) {
                Ok(c) => {
                    *cached_ctx = Some(c);
                    *cached_path = Some(path.to_string());
                    Ok(())
                }
                Err(e) => Err(format!("failed to load model: {e}")),
            }
        };

        let transcribe = |ctx: &WhisperContext,
                          audio: &[f32],
                          sr: u32,
                          language: Option<String>|
         -> Result<String, String> {
            let mut state = ctx.create_state().map_err(|e| format!("state: {e}"))?;
            let mut params = FullParams::new(SamplingStrategy::Greedy { best_of: 1 });
            let threads = std::thread::available_parallelism()
                .unwrap_or_else(|_| NonZeroUsize::new(2).unwrap())
                .get();
            params.set_n_threads(threads as i32);
            if let Some(lang) = language.as_deref() {
                params.set_language(Some(lang));
            } else {
                params.set_language(None);
            }
            params.set_translate(false);
            params.set_print_realtime(false);
            params.set_print_progress(false);
            params.set_print_timestamps(false);

            let pcm = if sr == 16_000 {
                audio.to_vec()
            } else {
                resample_to_16k(audio, sr)
            };
            state
                .full(params, &pcm)
                .map_err(|e| format!("transcribe: {e}"))?;
            let num_segments = state
                .full_n_segments()
                .map_err(|e| format!("segments: {e}"))?;
            let mut out = String::new();
            for i in 0..num_segments {
                out.push_str(&state.full_get_segment_text(i).unwrap_or_default());
            }
            Ok(out.trim().to_string())
        };

        while let Ok(cmd) = cmd_rx.recv() {
            match cmd {
                SpeechCommand::Start { model_path, language } => {
                    lang_opt = language;
                    if !Path::new(&model_path).exists() {
                        let _ = evt_tx.send(SpeechEvent::Error(format!(
                            "Model not found at {model_path}"
                        )));
                        continue;
                    }
                    if let Some(mut buf) = audio_buf.try_lock() {
                        buf.clear();
                    }
                    if stream.is_some() {
                        let _ = evt_tx.send(SpeechEvent::RecordingStarted);
                        continue;
                    }
                    let device = match host.default_input_device() {
                        Some(d) => d,
                        None => {
                            let _ = evt_tx.send(SpeechEvent::Error(
                                "No input device available".into(),
                            ));
                            continue;
                        }
                    };
                    let supported = match device.default_input_config() {
                        Ok(c) => c,
                        Err(e) => {
                            let _ = evt_tx.send(SpeechEvent::Error(format!(
                                "Failed to get input config: {e}"
                            )));
                            continue;
                        }
                    };
                    last_sr = supported.sample_rate().0;
                    last_channels = supported.channels();
                    let stream_config: StreamConfig = supported.clone().into();
                    let err_tx = evt_tx.clone();
                    let buf_clone = audio_buf.clone();
                    let build_stream = |sample_format: SampleFormat| -> Result<Stream, String> {
                        match sample_format {
                            SampleFormat::F32 => device
                                .build_input_stream(
                                    &stream_config,
                                    move |data: &[f32], _| {
                                        push_samples(&buf_clone, data, last_channels);
                                    },
                                    move |e| {
                                        let _ = err_tx.send(SpeechEvent::Error(format!(
                                            "Input stream error: {e}"
                                        )));
                                    },
                                    None,
                                )
                                .map_err(|e| format!("Failed to build input stream: {e}")),
                            SampleFormat::I16 => device
                                .build_input_stream(
                                    &stream_config,
                                    move |data: &[i16], _| {
                                        let mut f32buf: Vec<f32> =
                                            data.iter().map(|s| *s as f32 / i16::MAX as f32).collect();
                                        push_samples(&buf_clone, &f32buf, last_channels);
                                    },
                                    move |e| {
                                        let _ = err_tx.send(SpeechEvent::Error(format!(
                                            "Input stream error: {e}"
                                        )));
                                    },
                                    None,
                                )
                                .map_err(|e| format!("Failed to build input stream: {e}")),
                            SampleFormat::U16 => device
                                .build_input_stream(
                                    &stream_config,
                                    move |data: &[u16], _| {
                                        let mut f32buf: Vec<f32> = data
                                            .iter()
                                            .map(|s| (*s as f32 / u16::MAX as f32) * 2.0 - 1.0)
                                            .collect();
                                        push_samples(&buf_clone, &f32buf, last_channels);
                                    },
                                    move |e| {
                                        let _ = err_tx.send(SpeechEvent::Error(format!(
                                            "Input stream error: {e}"
                                        )));
                                    },
                                    None,
                                )
                                .map_err(|e| format!("Failed to build input stream: {e}")),
                            _ => Err(format!(
                                "Unsupported input sample format: {:?}",
                                sample_format
                            )),
                        }
                    };

                    match build_stream(supported.sample_format()) {
                        Ok(s) => {
                            if let Err(e) = s.play() {
                                let _ = evt_tx.send(SpeechEvent::Error(format!(
                                    "Failed to start capture: {e}"
                                )));
                            } else {
                                stream = Some(s);
                                let _ = evt_tx.send(SpeechEvent::RecordingStarted);
                            }
                        }
                        Err(e) => {
                            let _ = evt_tx.send(SpeechEvent::Error(e));
                        }
                    }
                    if let Err(e) = load_ctx(&model_path, &mut ctx_model, &mut ctx) {
                        let _ = evt_tx.send(SpeechEvent::Error(e));
                    }
                }
                SpeechCommand::Stop | SpeechCommand::Cancel => {
                    if stream.is_some() {
                        stream = None;
                        let _ = evt_tx.send(SpeechEvent::RecordingStopped);
                    }
                    let samples = {
                        if let Some(mut guard) = audio_buf.try_lock() {
                            let data = guard.clone();
                            guard.clear();
                            data
                        } else {
                            Vec::new()
                        }
                    };
                    let _ = evt_tx.send(SpeechEvent::Info(format!(
                        "Captured {} samples @ {} Hz",
                        samples.len(),
                        last_sr
                    )));
                    if samples.is_empty() {
                        continue;
                    }
                    let _ = evt_tx.send(SpeechEvent::Processing);
                    if let Some(ctx_loaded) = ctx.as_ref() {
                        match transcribe(ctx_loaded, &samples, last_sr, lang_opt.clone()) {
                            Ok(t) => {
                                let _ = evt_tx.send(SpeechEvent::Info(format!(
                                    "Transcript length: {} chars",
                                    t.len()
                                )));
                                let _ = evt_tx.send(SpeechEvent::Transcript(t));
                            }
                            Err(e) => {
                                let _ = evt_tx.send(SpeechEvent::Error(e));
                            }
                        }
                    } else {
                        let _ = evt_tx.send(SpeechEvent::Error(
                            "Model not loaded; cannot transcribe".into(),
                        ));
                    }
                }
            }
        }
    });
    Ok((cmd_tx, evt_rx))
}

fn push_samples(buf: &Arc<Mutex<Vec<f32>>>, data: &[f32], channels: u16) {
    let mut guard = match buf.try_lock() {
        Some(g) => g,
        None => return,
    };
    for frame in data.chunks(channels as usize) {
        let mut sum = 0.0f32;
        for s in frame {
            sum += *s;
        }
        guard.push(sum / channels as f32);
        if guard.len() > MAX_SAMPLES {
            let drop = guard.len() - MAX_SAMPLES;
            guard.drain(0..drop);
        }
    }
}

fn resample_to_16k(samples: &[f32], from_rate: u32) -> Vec<f32> {
    if from_rate == 16_000 || samples.is_empty() {
        return samples.to_vec();
    }
    let ratio = 16_000f32 / from_rate as f32;
    let new_len = (samples.len() as f32 * ratio).ceil() as usize;
    let mut out = Vec::with_capacity(new_len);
    for i in 0..new_len {
        let src_pos = i as f32 / ratio;
        let idx = src_pos.floor() as usize;
        let frac = src_pos - idx as f32;
        let s0 = *samples.get(idx).unwrap_or(&0.0);
        let s1 = *samples.get(idx + 1).unwrap_or(&s0);
        out.push(s0 + (s1 - s0) * frac);
    }
    out
}

// ----- Overlay (recording HUD) -----

enum OverlayMsg {
    RecordingStart,
    Processing,
    Transcript(String),
    Hide,
}

struct OverlayState {
    recording: bool,
    processing: bool,
    text: String,
    visible: bool,
    last_update: Instant,
    blink_on: bool,
}

struct OverlayHandle {
    tx: Sender<OverlayMsg>,
}

impl OverlayHandle {
    fn send(&self, msg: OverlayMsg) {
        let _ = self.tx.send(msg);
    }
}

fn start_overlay() -> OverlayHandle {
    let (tx, rx) = mpsc::channel::<OverlayMsg>();
    thread::spawn(move || {
        if let Err(e) = run_overlay(rx) {
            eprintln!("overlay error: {e}");
        }
    });
    OverlayHandle { tx }
}

fn run_overlay(rx: Receiver<OverlayMsg>) -> Result<(), String> {
    unsafe {
        let hinstance = GetModuleHandleW(std::ptr::null());
        let class_name = wide("WhisOverlay");
        let wc = WNDCLASSW {
            style: 0,
            lpfnWndProc: Some(overlay_wnd_proc),
            cbClsExtra: 0,
            cbWndExtra: 0,
            hInstance: hinstance,
            hIcon: LoadIconW(0, IDI_APPLICATION as *const u16),
            hCursor: 0,
            hbrBackground: 0 as HBRUSH,
            lpszMenuName: std::ptr::null(),
            lpszClassName: class_name.as_ptr(),
        };
        if RegisterClassW(&wc) == 0 {
            return Err("RegisterClassW failed".into());
        }

        let hwnd = CreateWindowExW(
            WS_EX_TOPMOST | WS_EX_TOOLWINDOW,
            class_name.as_ptr(),
            class_name.as_ptr(),
            WS_POPUP,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            OVERLAY_WIDTH,
            OVERLAY_HEIGHT,
            0,
            0,
            hinstance,
            std::ptr::null(),
        );
        if hwnd == 0 {
            return Err("CreateWindowExW failed".into());
        }

        let mut state = OverlayState {
            recording: false,
            processing: false,
            text: String::from("Overlay test..."),
            visible: true, // force-visible for debug
            last_update: std::time::Instant::now(),
            blink_on: true,
        };

        // Position at bottom center
        let sx = GetSystemMetrics(0);
        let sy = GetSystemMetrics(1);
        let x = (sx - OVERLAY_WIDTH) / 2;
        let y = sy - OVERLAY_HEIGHT - 40;
        MoveWindow(hwnd, x, y, OVERLAY_WIDTH, OVERLAY_HEIGHT, 1);
        SetWindowPos(
            hwnd,
            HWND_TOPMOST,
            x,
            y,
            OVERLAY_WIDTH,
            OVERLAY_HEIGHT,
            SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW,
        );
        ShowWindow(hwnd, SW_SHOWNOACTIVATE);
        draw_overlay(hwnd, &state);

        loop {
            // Process overlay messages
            match rx.recv_timeout(Duration::from_millis(50)) {
                Ok(msg) => {
                    match msg {
                        OverlayMsg::RecordingStart => {
                            state.recording = true;
                            state.processing = false;
                            state.text.clear();
                            state.visible = true;
                            state.last_update = std::time::Instant::now();
                        }
                        OverlayMsg::Processing => {
                            state.processing = true;
                            state.recording = false;
                            state.visible = true;
                            state.last_update = std::time::Instant::now();
                        }
                        OverlayMsg::Transcript(t) => {
                            state.text = t;
                            state.processing = false;
                            state.recording = false;
                            state.visible = true;
                            state.last_update = std::time::Instant::now();
                        }
                        OverlayMsg::Hide => {
                            state.recording = false;
                            state.processing = false;
                            state.visible = false;
                        }
                    }
                    if state.visible {
                        SetWindowPos(
                            hwnd,
                            HWND_TOPMOST,
                            0,
                            0,
                            0,
                            0,
                            SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW,
                        );
                        ShowWindow(hwnd, SW_SHOWNOACTIVATE);
                        draw_overlay(hwnd, &state);
                    } else {
                        ShowWindow(hwnd, SW_HIDE);
                    }
                }
                Err(std::sync::mpsc::RecvTimeoutError::Timeout) => {
                    // auto-hide when idle
                    if state.visible && !state.recording && !state.processing {
                        if state.last_update.elapsed().as_millis() > OVERLAY_HIDE_DELAY_MS {
                            state.visible = false;
                            ShowWindow(hwnd, SW_HIDE);
                        }
                    }
                    // blink toggle
                    if state.recording || state.processing {
                        state.blink_on = !state.blink_on;
                    }
                    if state.visible {
                        draw_overlay(hwnd, &state);
                    }
                }
                Err(std::sync::mpsc::RecvTimeoutError::Disconnected) => break,
            }
            // Pump window messages
            let mut msg: MSG = std::mem::zeroed();
            while PeekMessageW(&mut msg, hwnd, 0, 0, PM_REMOVE) != 0 {
                if msg.message == WM_QUIT as u32 {
                    return Ok(());
                }
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
        }
        Ok(())
    }
}

#[allow(non_snake_case)]
extern "system" fn overlay_wnd_proc(
    hwnd: HWND,
    msg: u32,
    wparam: WPARAM,
    lparam: LPARAM,
) -> LRESULT {
    unsafe {
        match msg {
            WM_PAINT => 0,
            WM_DESTROY => {
                PostQuitMessage(0);
                0
            }
            _ => DefWindowProcW(hwnd, msg, wparam, lparam),
        }
    }
}

fn draw_overlay(hwnd: HWND, state: &OverlayState) {
    unsafe {
        let hdc = GetDC(hwnd);
        if hdc == 0 {
            return;
        }
        let dc = hdc;

        let rect = RECT {
            left: 0,
            top: 0,
            right: OVERLAY_WIDTH,
            bottom: OVERLAY_HEIGHT,
        };
        // black background
        let back_br = CreateSolidBrush(colorref(0, 0, 0));
        FillRect(dc, &rect, back_br);
        DeleteObject(back_br as _);

        // Text color white
        SetTextColor(dc, colorref(255, 255, 255));
        SetBkMode(dc, TRANSPARENT as i32);

        // Blinking circle
        let dot_br = CreateSolidBrush(if state.blink_on {
            colorref(200, 40, 40)
        } else {
            colorref(120, 120, 120)
        });
        let circle_size = 18;
        let old = SelectObject(dc, dot_br as _);
        Ellipse(
            dc,
            12,
            (OVERLAY_HEIGHT - circle_size) / 2,
            12 + circle_size,
            (OVERLAY_HEIGHT - circle_size) / 2 + circle_size,
        );
        if old != 0 {
            SelectObject(dc, old);
        }
        DeleteObject(dot_br as _);

        // Status line
        let status = if state.recording {
            "Recording..."
        } else if state.processing {
            "Processing..."
        } else {
            "Transcript"
        };
        let status_w = wide(&format!("WhisTxtR - {}", status));
        let status_rect = RECT {
            left: 40,
            top: 14,
            right: OVERLAY_WIDTH - 10,
            bottom: 40,
        };
        TextOutW(
            dc,
            status_rect.left,
            status_rect.top,
            status_w.as_ptr(),
            (status_w.len() - 1) as i32,
        );

        // Body text
        let body = if state.recording {
            if state.text.is_empty() {
                "Listening..."
            } else {
                state.text.as_str()
            }
        } else if state.processing {
            "Processing..."
        } else if state.text.is_empty() {
            "No transcript"
        } else {
            state.text.as_str()
        };
        let body_w = wide(body);
        let body_rect = RECT {
            left: 12,
            top: 50,
            right: OVERLAY_WIDTH - 12,
            bottom: OVERLAY_HEIGHT - 12,
        };
        TextOutW(
            dc,
            body_rect.left,
            body_rect.top,
            body_w.as_ptr(),
            (body_w.len() - 1) as i32,
        );

        ReleaseDC(hwnd, hdc);
    }
}

fn GetSystemMetrics(index: i32) -> i32 {
    unsafe { windows_sys::Win32::UI::WindowsAndMessaging::GetSystemMetrics(index) }
}

fn colorref(r: u8, g: u8, b: u8) -> u32 {
    (r as u32) | ((g as u32) << 8) | ((b as u32) << 16)
}

// ----- Win32 tray (NotifyIcon) -----

enum TrayCmd {
    Quit,
    ToggleStartup,
}

struct Tray {
    hwnd: HWND,
    hmenu: HMENU,
    cmd_rx: Receiver<TrayCmd>,
}

static mut TRAY_CMD_TX: Option<Sender<TrayCmd>> = None;
fn send_tray_cmd(cmd: TrayCmd) {
    unsafe {
        if let Some(tx) = TRAY_CMD_TX.as_ref() {
            let _ = tx.send(cmd);
        }
    }
}

impl Tray {
    fn start(startup_checked: bool) -> Result<Self, AppError> {
        unsafe {
            let hinstance = GetModuleHandleW(std::ptr::null());
            let class_name = wide("WhisTrayHidden");
            let wc = WNDCLASSW {
                style: 0,
                lpfnWndProc: Some(tray_wnd_proc),
                cbClsExtra: 0,
                cbWndExtra: 0,
                hInstance: hinstance,
                hIcon: LoadIconW(0, IDI_APPLICATION as *const u16),
                hCursor: 0,
                hbrBackground: 0 as HBRUSH,
                lpszMenuName: std::ptr::null(),
                lpszClassName: class_name.as_ptr(),
            };
            if RegisterClassW(&wc) == 0 {
                return Err(AppError::Msg("RegisterClassW failed".into()));
            }

            let hwnd = CreateWindowExW(
                0,
                class_name.as_ptr(),
                class_name.as_ptr(),
                WS_OVERLAPPEDWINDOW,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                0,
                0,
                hinstance,
                std::ptr::null(),
            );
            if hwnd == 0 {
                return Err(AppError::Msg("CreateWindowExW failed".into()));
            }

            let hmenu = CreatePopupMenu();
            append_menu_str(hmenu, ID_TRAY_STARTUP as u32, startup_label(startup_checked));
            append_menu_str(hmenu, ID_TRAY_QUIT as u32, "Quit");

            let (tx, rx) = mpsc::channel::<TrayCmd>();
            TRAY_CMD_TX = Some(tx);

            let mut nid: NOTIFYICONDATAW = std::mem::zeroed();
            nid.cbSize = std::mem::size_of::<NOTIFYICONDATAW>() as u32;
            nid.hWnd = hwnd;
            nid.uID = 1;
            nid.uFlags = NIF_MESSAGE | NIF_TIP | NIF_ICON;
            nid.uCallbackMessage = WM_TRAYICON;
            nid.hIcon = LoadImageW(
                0,
                IDI_APPLICATION as *const u16,
                IMAGE_ICON,
                16,
                16,
                LR_SHARED,
            ) as isize;
            let tip = wide("WhisTxtR (right-click for menu)");
            nid.szTip[..tip.len()].copy_from_slice(&tip);
            Shell_NotifyIconW(NIM_ADD, &mut nid);

            Ok(Tray { hwnd, hmenu, cmd_rx: rx })
        }
    }

    fn pump(&mut self) -> bool {
        unsafe {
            let mut msg: MSG = std::mem::zeroed();
            while PeekMessageW(&mut msg, 0, 0, 0, PM_REMOVE) != 0 {
                if msg.message == WM_QUIT as u32 {
                    send_tray_cmd(TrayCmd::Quit);
                    return false;
                }
                TranslateMessage(&msg);
                DispatchMessageW(&msg);
            }
        }
        true
    }

    fn try_recv_cmd(&self) -> Option<TrayCmd> {
        self.cmd_rx.try_recv().ok()
    }

    fn set_startup_checked(&self, on: bool) {
        unsafe {
            // Rebuild the menu label to reflect current state.
            while RemoveMenu(self.hmenu, 0, MF_BYPOSITION) != 0 {}
            append_menu_str(self.hmenu, ID_TRAY_STARTUP as u32, startup_label(on));
            append_menu_str(self.hmenu, ID_TRAY_QUIT as u32, "Quit");
        }
    }
}

fn startup_label(enabled: bool) -> &'static str {
    if enabled {
        "Disable Start with Windows"
    } else {
        "Enable Start with Windows"
    }
}

extern "system" fn tray_wnd_proc(
    hwnd: HWND,
    msg: u32,
    wparam: WPARAM,
    lparam: LPARAM,
) -> LRESULT {
    unsafe {
        match msg {
            WM_TRAYICON => {
                if lparam as u32 == WM_RBUTTONUP {
                    SetForegroundWindow(hwnd);
                    // Build a fresh menu near the cursor.
                    let hmenu = CreatePopupMenu();
                    let startup = is_startup_enabled();
                    append_menu_str(hmenu, ID_TRAY_STARTUP as u32, startup_label(startup));
                    append_menu_str(hmenu, ID_TRAY_QUIT as u32, "Quit");
                    let mut pt = POINT { x: 0, y: 0 };
                    GetCursorPos(&mut pt);
                    let sel = TrackPopupMenu(
                        hmenu,
                        TPM_LEFTALIGN | TPM_BOTTOMALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                        pt.x,
                        pt.y,
                        0,
                        hwnd,
                        std::ptr::null(),
                    );
                    match sel as u16 {
                        ID_TRAY_QUIT => {
                            send_tray_cmd(TrayCmd::Quit);
                            PostQuitMessage(0);
                        }
                        ID_TRAY_STARTUP => {
                            send_tray_cmd(TrayCmd::ToggleStartup);
                        }
                        _ => {}
                    }
                    // Per docs, post a null message after TrackPopupMenu.
                    PostMessageW(hwnd, WM_NULL, 0, 0);
                }
                0
            }
            WM_COMMAND => {
                let id = (wparam & 0xFFFF) as u16;
                match id {
                    ID_TRAY_QUIT => {
                        send_tray_cmd(TrayCmd::Quit);
                        PostQuitMessage(0);
                    }
                    ID_TRAY_STARTUP => {
                        send_tray_cmd(TrayCmd::ToggleStartup);
                    }
                    _ => {}
                }
                0
            }
            WM_DESTROY => {
                Shell_NotifyIconW(
                    NIM_DELETE,
                    &mut NOTIFYICONDATAW {
                        cbSize: std::mem::size_of::<NOTIFYICONDATAW>() as u32,
                        hWnd: hwnd,
                        uID: 1,
                        ..unsafe { std::mem::zeroed() }
                    },
                );
                PostQuitMessage(0);
                0
            }
            _ => DefWindowProcW(hwnd, msg, wparam, lparam),
        }
    }
}

fn append_menu_str(hmenu: HMENU, id: u32, label: &str) {
    let w = wide(label);
    unsafe {
        windows_sys::Win32::UI::WindowsAndMessaging::AppendMenuW(
            hmenu,
            0,
            id as usize,
            w.as_ptr(),
        );
    }
}

fn wide(s: &str) -> Vec<u16> {
    use std::os::windows::ffi::OsStrExt;
    std::ffi::OsStr::new(s).encode_wide().chain(std::iter::once(0)).collect()
}
